<!DOCTYPE html>

<html lang="ja">

<head>

    <meta charset="UTF-8">

    <title>PANZER VOR!</title>

    <link
        href="https://fonts.googleapis.com/css2?family=UnifrakturMaguntia&family=Cormorant+Garamond:wght@300;400;600&display=swap"
        rel="stylesheet">

    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@900&display=swap" rel="stylesheet">

    <style>
        body {
            background: #bc1000;

            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        canvas {
            background: #000;
            border: 10px solid #fff;
        }
    </style>

</head>

<body>

    <canvas id="gameCanvas" width="400" height="600"></canvas>



    <script>

        const canvas = document.getElementById("gameCanvas");

        const ctx = canvas.getContext("2d");



        let score = 0;

        let highScore = localStorage.getItem("highScore") || 0;

        let gameOver = false;

        let gameStarted = false;



        // --- 2. 画像の読み込み ---

        const playerImg = new Image();

        playerImg.src = "img/player.png";

        const enemyImg = new Image();

        enemyImg.src = "img/enemy.png";

        const bulletImg = new Image();

        bulletImg.src = "img/bullet.png";

        const enemyBulletImg = new Image();

        enemyBulletImg.src = "img/enemy_bullet.png";



        // --- 音楽の設定 ---

        const bgm = new Audio("audio/bgm.mp3");

        bgm.loop = true;

        bgm.volume = 0.5;

        let isMusicPlaying = false;



        // --- 3. プレイヤーの設定 ---

        let player = {

            x: 150,

            y: 450,

            width: 100,

            height: 100,

            hitWidth: 40,

            hitHeight: 40,

            speed: 4,

            recoil: 0

        };



        let lastShotTime = 0;

        const shotInterval = 250;

        let bullets = [];

        let enemyBullets = [];

        let enemies = [];

        let keys = {};



        let shakeDuration = 0;

        let shakeIntensity = 5;



        // --- 4. イベントリスナー ---

        window.addEventListener("keydown", e => {
            keys[e.code] = true;

            // --- スタート・リプレイのキー判定 ---
            if (e.code === "Enter" || e.code === "Space") {
                if (!gameStarted) {
                    // タイトル画面なら開始
                    gameStarted = true;
                    if (!isMusicPlaying) {
                        bgm.play().catch(err => console.log("Audio play blocked"));
                        isMusicPlaying = true;
                    }
                } else if (gameOver) {
                    // ゲームオーバーならリセット
                    resetGame();
                    bgm.play().catch(err => console.log("Audio play blocked"));
                    isMusicPlaying = true;
                }
            }
        });

        window.addEventListener("keyup", e => keys[e.code] = false);



        canvas.addEventListener("click", e => {

            const rect = canvas.getBoundingClientRect();

            const mouseX = e.clientX - rect.left;

            const mouseY = e.clientY - rect.top;



            // 1. タイトル画面でのスタート判定

            if (!gameStarted) {

                gameStarted = true;

                if (!isMusicPlaying) {

                    bgm.play().catch(err => console.log("Audio play blocked"));

                    isMusicPlaying = true;

                }

                return;

            }



            // 2. ゲームオーバー画面でのリプレイボタン判定

            if (gameOver) {

                if (mouseX >= 100 && mouseX <= 300 && mouseY >= 350 && mouseY <= 400) {

                    resetGame(); // ★ ここでエラーが起きていたのを修正

                    bgm.play().catch(err => console.log("Audio play blocked"));

                    isMusicPlaying = true;

                }

            }

        });



        function startGame() {
            gameStarted = true;
            if (!isMusicPlaying) {
                bgm.play().catch(err => console.log("Audio play blocked"));
                isMusicPlaying = true;
            }
        }



        // --- 5. ゲームループ ---

        function gameLoop() {

            if (!gameStarted) {

                // タイトル画面の描画

                ctx.clearRect(0, 0, canvas.width, canvas.height);

                ctx.textAlign = "center";

                ctx.textBaseline = "middle";

                ctx.fillStyle = "white";

                ctx.font = "900 48px 'Futura', 'Montserrat', sans-serif";

                ctx.fillText("PANZER VOR!", canvas.width / 2, 200);

                ctx.font = "900 18px 'Futura', 'Montserrat', sans-serif";

                ctx.fillText("1944: SCHLACHT IM OSTEN", canvas.width / 2, 260);

                ctx.font = "900 22px 'Futura', 'Montserrat', sans-serif";

                ctx.fillStyle = "#bc1000";

                // gameLoop() 内のタイトル描画部分
                ctx.fillText("CLICK or PRESS ENTER", canvas.width / 2, 420);

                requestAnimationFrame(gameLoop);

                return;

            }



            if (gameOver) {
                draw(); // まず現在のゲーム画面を描画
                ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // テキスト設定をリセット（ここが重要！）
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                const centerX = canvas.width / 2;

                // 1. "GAME OVER"
                ctx.fillStyle = "#bc1000";
                ctx.font = "900 48px 'Futura', 'Montserrat', sans-serif";
                ctx.fillText("GAME OVER", centerX, 200);

                // 2. スコア表示
                ctx.fillStyle = "white";
                ctx.font = "900 30px 'Futura', 'Montserrat', sans-serif";
                ctx.fillText(`SCORE: ${score}`, centerX, 270);

                // 3. リプレイボタン（背景の赤枠）
                const btnW = 220;
                const btnH = 50;
                const btnX = centerX - btnW / 2;
                const btnY = 350;

                ctx.fillStyle = "#bc1000";
                ctx.fillRect(btnX, btnY, btnW, btnH);
                ctx.strokeStyle = "white";
                ctx.lineWidth = 2;
                ctx.strokeRect(btnX, btnY, btnW, btnH);

                // 4. ボタン内の文字
                ctx.fillStyle = "white";
                ctx.font = "900 22px 'Futura', 'Montserrat', sans-serif";
                ctx.fillText("REPLAY", centerX, btnY + btnH / 2);

                requestAnimationFrame(gameLoop);
                return;
            }


            update();

            draw();

            requestAnimationFrame(gameLoop);

        }



        // ★ 追加：リセット関数がないとリプレイできませんでした

        function resetGame() {

            player.x = 150;

            player.y = 450;

            bullets = [];

            enemyBullets = [];

            enemies = [];

            score = 0;

            gameOver = false;

        }



        function triggerGameOver() {

            gameOver = true;

            shakeDuration = 30;

            bgm.pause();

            bgm.currentTime = 0;

            isMusicPlaying = false;

            if (score > highScore) {

                highScore = score;

                localStorage.setItem("highScore", highScore);

            }

        }



        // --- 6. 更新処理 ---

        function update() {

            if ((keys["KeyW"] || keys["ArrowUp"]) && player.y > 0) player.y -= player.speed;

            if ((keys["KeyS"] || keys["ArrowDown"]) && player.y < canvas.height - player.height) player.y += player.speed;

            if ((keys["KeyA"] || keys["ArrowLeft"]) && player.x > 0) player.x -= player.speed;

            if ((keys["KeyD"] || keys["ArrowRight"]) && player.x < canvas.width - player.width) player.x += player.speed;



            if (player.recoil > 0) {

                player.recoil *= 0.8;

                if (player.recoil < 0.1) player.recoil = 0;

            }



            if (keys["Space"]) {

                const currentTime = Date.now();

                if (currentTime - lastShotTime > shotInterval) {

                    const bSize = 40;

                    bullets.push({

                        x: player.x + player.width / 2 - bSize / 2,

                        y: player.y,

                        width: bSize,

                        height: bSize

                    });

                    lastShotTime = currentTime;

                    player.recoil = 10;

                }

            }



            for (let i = bullets.length - 1; i >= 0; i--) {

                bullets[i].y -= 7;

                if (bullets[i].y < -bullets[i].height) bullets.splice(i, 1);

            }

            // --- 敵の生成ロジックの強化 ---

            // 基本の出現率 0.03 (3%) に、スコア100ごとに 0.01 ずつ加算する例
            // Math.min で最大値を制限（0.15 = 15%）しないと、画面が敵で埋め尽くされます
            let spawnRate = 0.03 + (Math.floor(score / 100) * 0.01);
            if (spawnRate > 0.15) spawnRate = 0.15;

            if (Math.random() < spawnRate) {
                enemies.push({
                    x: Math.random() * (canvas.width - 100),
                    y: -100,
                    width: 100,
                    height: 100,
                    hitWidth: 60,
                    hitHeight: 60,
                    // スコアに応じて敵の移動速度も少しずつ上げる（オプション）
                    speed: 3 + Math.min(score / 500, 4)
                });
            }



            for (let i = enemies.length - 1; i >= 0; i--) {

                let en = enemies[i];

                en.y += 3;

                if (Math.random() < 0.005) {

                    enemyBullets.push({

                        x: en.x + en.width / 2 - 20,

                        y: en.y + en.height,

                        width: 40,

                        height: 40

                    });

                }

                let px = player.x + (player.width - player.hitWidth) / 2;

                let py = player.y + (player.height - player.hitHeight) / 2;

                let ex = en.x + (en.width - en.hitWidth) / 2;

                let ey = en.y + (en.height - en.hitHeight) / 2;

                if (rectIntersect(px, py, player.hitWidth, player.hitHeight, ex, ey, en.hitWidth, en.hitHeight)) {

                    triggerGameOver();

                }

                for (let bi = bullets.length - 1; bi >= 0; bi--) {

                    let b = bullets[bi];

                    if (rectIntersect(ex, ey, en.hitWidth, en.hitHeight, b.x, b.y, b.width, b.height)) {

                        enemies.splice(i, 1);

                        bullets.splice(bi, 1);

                        score += 10;

                        shakeDuration = 10;

                        break;

                    }

                }

                if (en && en.y > canvas.height) enemies.splice(i, 1);

            }



            for (let i = enemyBullets.length - 1; i >= 0; i--) {

                let eb = enemyBullets[i];

                eb.y += 5;

                let px = player.x + (player.width - player.hitWidth) / 2;

                let py = player.y + (player.height - player.hitHeight) / 2;

                if (rectIntersect(px, py, player.hitWidth, player.hitHeight, eb.x, eb.y, eb.width, eb.height)) {

                    triggerGameOver();

                }

                if (eb.y > canvas.height) enemyBullets.splice(i, 1);

            }

        }



        // --- 7. 描画処理 ---

        function draw() {

            ctx.save();

            ctx.textAlign = "left";

            ctx.textBaseline = "alphabetic";

            if (shakeDuration > 0) {

                const dx = (Math.random() - 0.5) * shakeIntensity;

                const dy = (Math.random() - 0.5) * shakeIntensity;

                ctx.translate(dx, dy);

                shakeDuration--;

            }

            ctx.clearRect(-20, -20, canvas.width + 40, canvas.height + 40);

            ctx.drawImage(playerImg, player.x, player.y + player.recoil, player.width, player.height);

            bullets.forEach(b => ctx.drawImage(bulletImg, b.x, b.y, b.width, b.height));

            enemies.forEach(en => ctx.drawImage(enemyImg, en.x, en.y, en.width, en.height));

            enemyBullets.forEach(eb => {

                ctx.drawImage(enemyBulletImg, eb.x, eb.y, eb.width, eb.height);

            });

            ctx.fillStyle = "#fff";

            ctx.font = "900 24px 'Futura', 'Montserrat', sans-serif";

            ctx.fillText(`SCORE: ${score}`, 10, 35);

            ctx.fillText(`BEST: ${highScore}`, 10, 65);

            ctx.restore();

        }



        function rectIntersect(x1, y1, w1, h1, x2, y2, w2, h2) {

            return x2 < x1 + w1 && x2 + w2 > x1 && y2 < y1 + h1 && y2 + h2 > y1;

        }



        // --- 8. 起動 ---

        let loadedImages = 0;

        function imageLoaded() {

            loadedImages++;

            if (loadedImages === 4) gameLoop();

        }

        playerImg.onload = enemyImg.onload = bulletImg.onload = enemyBulletImg.onload = imageLoaded;

    </script>

</body>

</html>